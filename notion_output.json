[
  {
    "title": "[TEST] How To Notion2Webflow",
    "body": "\n![Image](https://prod-files-secure.s3.us-west-2.amazonaws.com/9cc5b8bb-075e-4435-b1fb-c3d115d21d00/e88d1559-c0e3-4757-a146-239df6220a95/How_to_Use_IPFS_for_Memecoins.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240524%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240524T141238Z&X-Amz-Expires=3600&X-Amz-Signature=18eae5a5cf48e5e6530ef30484f71906b39f4d933ca8a01edae98d5fc85d88f0&X-Amz-SignedHeaders=host&x-id=GetObject)\n[I recently wrote about how to launch a memecoin on Farcaster](https://www.pinata.cloud/blog/how-to-launch-a-memecoin-on-farcaster), but there are, of course, plenty of memecoins that are not native to [Farcaster](https://www.pinata.cloud/blog/what-is-farcaster). While not all memecoins share the same distribution mechanisms, many of them do share one important characteristic. The meme images associated with these tokens are stored on IPFS. \nThere are thousands and thousands of memecoins across all blockchains, but they behave differently. For example, a memecoin like Degen on Farcaster doesn’t have images associated with the individual tokens. Instead, Degen leverages images as a community-building tool. Contrast that with a platform like [pump.fun](http://pump.fun/), which allows anyone to launch a memecoin. Each memecoin launched requires an image. The goal is to create funny and engaging memes that are also tokens. Of course, there are variations that run the gamut between these two examples, but images are a center piece to all of them. \nToday, we’re going to walk through how easy it is to upload and associated memecoin images with IPFS by using Pinata. \n## Getting Started\nWe’re going to use Pinata to upload memecoin images to IPFS, and we’re going to use a [dedicated IPFS gateway](https://www.pinata.cloud/blog/how-to-use-dedicated-gateways) to ensure these images load quickly and reliably every time, no matter where they are served. So, [go ahead and sign up for a free Pinata account here](https://pinata.cloud/). \nWhile we will not be deploying smart contracts in this guide, we will show how you create the correct metadata to associate these memecoins with the tokens that will be deployed. We’ll do this for both Ethereum-based blockchains (EVM) and for Solana. \nYou’ll need a code editor, Node.js, and your computer’s terminal app to work on this project. Now, let’s get to it. \n### The Code\nWe’re going to use Next.js for this project. You could choose to generalize this and extract the pieces to allow you to do something a little more modular like React + Express or React + Cloudflare Workers if you wanted to, but for simplicity, Next.js gets us the frontend code and backend code in one place. \nIn this tutorial, we’re going to let people create their own memecoins. Again, we won’t be touching the blockchain side of the deployment, but we will be building out the meme creation and upload process. This will result in the metadata you need for each memecoin. \nLet’s create our project using Next.js. Open your terminal and navigate to the folder where you keep all your projects. From there, run this command: \n```typescript\nnpx create-next-app\n```\nGive your project a name (I’m calling mine “memecoin-uploaded”) and follow the prompts. You can choose whatever you want for each prompt, but I’m going with the defaults which includes Typescript, App Router, Src directory, and no ES Lint. \nNow, change into your project directory: \n```typescript\ncd memecoin-uploader\n```\nIf you’re not familiar with Next.js 14, take a look at the project structure. Everything happens inside the src folder. Inside that folder, you have an app directory where all the individual app pages will be created. For this, we’ll just have one page. But what about our API? We’ll need some backend code, so let’s make that happen. \nInside the src folder create a new folder called api. Create another folder inside the api folder called upload. Then, add a file inside the key folder called route.ts. This file is going to be where we make post requests to get a one-time use key for upload. [We’ve written before about creating signed JWTs](https://www.pinata.cloud/blog/how-to-upload-to-ipfs-from-the-frontend-with-signed-jwts) that will allow safe uploads from frontend clients. That’s exactly what we’ll be doing here. \nWe’ll need to generate an API key from Pinata to use within our backend code. So, go ahead and sign into Pinata and visit the API keys page. Create a new Admin key. When you’re done you’ll be provided a key, secret, and JWT. Grab the JWT and let’s add it to a .env file inside the root of our project (create that file if it doesn’t exist yet): \n```typescript\nPINATA_KEY=YOUR_JWT_HERE\n```\nNow, let’s use the Pinata API to create a one-time use key. Go back to your key/route.ts file and add the following: \n```typescript\nimport { NextResponse } from \"next/server\";\n\nexport const dynamic = 'force-dynamic'\n\nexport async function POST(request: Request) {\n  try {\n    const keyRestrictions = {\n      keyName: 'Signed Upload JWT',\n      maxUses: 2,\n      permissions: {\n        endpoints: {\n          data: {\n            pinList: false,\n            userPinnedDataTotal: false\n          },\n          pinning: {\n            pinFileToIPFS: true,\n            pinJSONToIPFS: true,\n            pinJobs: false,\n            unpin: false,\n            userPinPolicy: false\n          }\n        }\n      }\n    }\n    const options = {\n      method: 'POST',\n      headers: {\n        accept: 'application/json',\n        'content-type': 'application/json',\n        authorization: `Bearer ${process.env.PINATA_KEY}`\n      }, \n      body: JSON.stringify(keyRestrictions)\n    };\n\n    const jwtRepsonse = await fetch('https://api.pinata.cloud/users/generateApiKey', options);\n    const json = await jwtRepsonse.json();\n    const { JWT } = json;\n    return NextResponse.json({ message: { token: JWT } }, { status: 200 });\n  } catch (error) {\n    console.log(error)\n    return NextResponse.json({ message: \"Server error\" }, { status: 500 });\n  }\n}\n```\nIn this code, we set the key restrictions (i.e. the scopes) and we use that in the body of our API request to Pinata to create a key. Notice that we are only allowing pinFileToIPFS and pinJSONToIPFS endpoints, and the key’s limited use is 2 because we’ll need to upload two files. This means that, once it’s used, a bad actor cannot get ahold of it and use it over and over again to spam your account, making the key infinitely safer to use in the browser than an admin key. \nOne quick note: You’ll notice the line export const dynamic = 'force-dynamic'. This ensures that Vercel, or whatever hosting provider you use, doesn’t cache the response from creating your API key. By default it will which means even though you think you’re creating a new key, you’ll just be getting back the previous cached one, which is absolutely not what we want. \nNow, anyone can access your API in its current form, so you might want to introduce your own authentication on your app. If you do that, you would need to validate the auth token, or whatever is passed in, as part of the request before generating the key. As an example of this, we’ll use Dynamic to set up an embedded wallet on our app, and we’ll send a token generated by Dynamic that we can verify on the server. \nLet’s go ahead and do that (and more) by moving to our frontend code. \nIn the src/app folder, find the page.tsx file. This is where we’re going to be setting up our app’s core functionality. Go ahead and remove everything in that file and replace it with this: \n```typescript\nexport default function Home() {\n  return (\n   <main className=\"min-h-screen bg-black text-white\">\n      <div className=\"h-full flex flex-col justify-center w-screen\">\n\n      </div>\n   </main>\n  );\n}\n\n```\nLet’s think about what we need to do here. We need to check if a user has connected their wallet (this will be necessary for minting memecoins, which we won’t tackle here). If they are not, we need to let them connect using Dynamic. If they are, we need to present a form that let’s the user add a name, description, and image for their memecoin. Let’s start with implementing the Dynamic wallet logic. \n[Go to Dynamic’s website and sign up for a free account](https://dynamic.xyz/). Once you’ve done that, you’ll land on a dashboard with instructions. The instructions may change, so please refer to their guides. I’m including the instructions as of the time of writing this article. Go ahead and install the Dynamic SDK and dependencies into your project by running: \n```typescript\nnpm install @dynamic-labs/sdk-react-core @dynamic-labs/ethereum\n```\nOnce that’s installed, we need to set up the Dynamic provider in our app. Update your src/app/page.tsx file to look like this: \n```typescript\n'use client'\nimport { DynamicContextProvider, DynamicWidget } from '@dynamic-labs/sdk-react-core';\nimport { EthereumWalletConnectors } from \"@dynamic-labs/ethereum\";\n\nexport default function Home() {\n  return (\n    <DynamicContextProvider\n    settings={{\n      environmentId: 'YOUR DYNAMIC ENVIRONMENT ID',\n      walletConnectors: [ EthereumWalletConnectors ],\n    }}>\n    <DynamicWidget />\n    <main className=\"min-h-screen bg-black text-white\">\n      <div className=\"h-full flex flex-col justify-center w-screen\">\n\n      </div>\n   </main>\n  </DynamicContextProvider>   \n  );\n}\n\n```\nYou’ll notice the only thing we changed here is we wrapped our entire app in the Dynamic provider. Once you have this set up, you can run your app and sign in with your favorite crypto wallet or create a wallet using your email. Complete the sign in flow on localhost, and you’ll see in your Dynamic dashboard that a user has been created. \nWe need to know if a user is connected or not so we can render the form. Let’s import Dynamic’s hook for managing login status. Add an additional import to the Dynamic React Core dependencies like this: \n```typescript\nimport { DynamicContextProvider, DynamicWidget, useIsLoggedIn } from '@dynamic-labs/sdk-react-core';\n```\nThen, right at the top of your function component, add this: \n```typescript\nconst isLoggedIn = useIsLoggedIn();\n```\nNow, we can simply check the isLoggedIn boolean to determine if we should allow memecoin creation. In between the empty div in your file, add the following: \n```typescript\n<Form />\n```\nThen, above your Home component, create a function component called Form like this: \n```javascript\nconst Form = () => {\n  const isLoggedIn = useIsLoggedIn();\n  const [name, setName] = useState(\"\")\n  const [description, setDescription] = useState(\"\")\n  const [file, setFile] = useState<any>(null)\n\n  const fileRef: any = useRef()\n\n  const handleSubmit = async (e: any) => {\n    e.preventDefault()\n  }\n\n  const handleNameChange = (e: any) => {\n    setName(e.target.value)\n  }\n\n  const handleDescriptionChange = (e: any) => {\n    setDescription(e.target.value)\n  }\n\n  const handleFileClick = () => {\n    fileRef?.current?.click()\n  }\n\n  const handleFileChange = (e: any) => {\n    setFile(e.target.files[0])\n  }\n  \n  return (\n    <div className=\"h-full flex flex-col justify-center w-screen\">\n      {\n        isLoggedIn &&\n        <form onSubmit={handleSubmit}>\n          <div>\n            <label>\n              Name <br />\n              <input type=\"text\" value={name} onChange={handleNameChange} />\n            </label>\n          </div>\n          <div>\n            <label>\n              Description <br />\n              <input type=\"text\" value={description} onChange={handleDescriptionChange} />\n            </label>\n          </div>\n          <div>\n            <label>\n              File <br />\n              <input name=\"filename\" className=\"hidden\" ref={fileRef} type=\"file\" accept=\"image/png, image/jpg, image/jpeg, image.gif\" onChange={handleFileChange} />\n              <p>{file?.name || \"\"}</p>\n              <button onClick={handleFileClick}>Select file</button>\n            </label>\n          </div>\n          <div>\n            <button type=\"submit\">Upload</button>\n          </div>\n        </form>\n      }\n    </div>\n  )\n}\n\n```\nThis is a very simple form that will allow us to collect a name, description, and image file for our memecoin. You can actually fire up your app and test this by running: \n```javascript\nnpm run dev\n```\nYou’ll be able to log in with Dynamic and select an image file. But we still need to upload the file and create the metadata necessary for our memecoin. Let’s do that now. \nWe have a handleSubmit function already. Let’s use that. Update it to look like this: \n```javascript\nconst handleSubmit = async (e: any) => {\n  e.preventDefault()\n  const keyRes = await fetch(`/api/key`, {\n    method: \"POST\",\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: null\n  })\n\n  const keyInfo = await keyRes.json()\n\n  if (keyInfo && keyInfo.message?.token) {\n    //  Now we can upload\n    const formData = new FormData();\n    formData.append(\"file\", file);\n\n    const metadata = JSON.stringify({\n      name: `${file.name}`,\n    });\n    formData.append(\"pinataMetadata\", metadata);\n\n    const options = JSON.stringify({\n      cidVersion: 1,\n    });\n    formData.append(\"pinataOptions\", options);\n\n    const uploadRes = await fetch(\n      \"https://api.pinata.cloud/pinning/pinFileToIPFS\",\n      {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${keyInfo.message.token}`,\n        },\n        body: formData,\n      },\n    );\n\n    const cidData = await uploadRes.json()\n    console.log(cidData)\n  }\n}\n```\nWe’re calling the API route we created to generate an API key, then we’re using that key after we build up our form data to upload our image. Once the image is uploaded, you’re logging out the IPFS info. However, we want to do more than that. We need to construct the token’s metadata. We’ll do that next, but there’s one other point to understand here…\nThe request to our key generation API is unprotected. You can use Dynamic to get an auth token and verify it, or you can use some other method of your choice, but you should not leave that API endpoint unrestricted in a production environment. \nOk, let’s create some metadata. \n## EVM ERC20 Metadata\nFor an ERC20 token on an EVM (Ethereum Virtual Machine) compatible blockchain, you’ll want your token’s metadata to be formatted like this: \n```javascript\n{\n\"name\": \"Token Name\",\n\"description\": \"Token Description\",\n\"external_url\": \"Any website\",\n\"decimals\": 18, //total decimal points to support for coin, the more decimals, the smallet the possible denomination\n\"image\": \"IPFS URI for image\"\n}\n```\nThis isn’t quite a “standard,” like NFT token metadata is, but many ERC20 project follow this format for uniformity. This metadata will be turned into a contract URI that can be called by anyone who wants to see it. Knowing this, we can take the data we have for our token creation and create a contractURI from similarly shaped JSON. \nBelow where we logged out the upload response for our image, add the following: \n```javascript\nconst contractUriJSON = {\n  name: name,\n  description: description,\n  external_url: \"https://pinata.cloud\",\n  decimals: 18,\n  image: `ipfs://${cidData.IpfsHash}`\n}\n\nconst jsonRes = await fetch('https://api.pinata.cloud/pinning/pinJSONToIPFS', {\n  method: \"POST\", \n  headers: {\n    'Autorization': `Bearer: ${keyInfo.message.token}`, \n    'Content-Type': 'application/json'\n  }, \n  body: JSON.stringify({\n    pinataOptions: {\n      cidVersion: 1, \n    }, \n    pinataMetadata: {\n      name: \"metadata.json\"\n    },\n    pinataContent: contractUriJSON\n  })\n})\n\nconst uriData = await jsonRes.json()\nconsole.log(uriData)\n```\nWe’re creating a JSON object that matches the metadata format we showed above. Then we are using the same limited time use key we already generated to upload the JSON to IPFS. Then, we are logging out the response. \nWhat does this look like for Solana?\n## Solana SPL Metadata\nSolana does have a defined metadata standard for its tokens. This is very similar to NFTs, and it’s not too far off from the ERC20 object we created above. For a Solana SPL token, you’ll need to create an object that looks like this: \n```javascript\n{\n\"name\": \"YOUR TOKEN NAME\",\n\"symbol\": \"YOUR TOKEN SYMBOL\",\n\"description\": \"YOUR TOKEN DESCRIPTION\",\n\"image\": \"YOUR IPFS URI\",\n\"attributes\": [] //Option attributes\n}\n```\nWe’re going to skip the attributes in our token and keep it simple. We don’t have a token symbol in our form, so we’ll hardcode that, but you could add one more field to create a symbol. Here’s how this would look in our code. Below the console log that shows the response from uploading the image, add the following: \n```javascript\nconst splJSON = {\n  name: name,\n  symbol: \"TKN\",\n  description: description,\n  image: `ipfs://${cidData.IpfsHash}`\n}\n\nconst jsonRes = await fetch('https://api.pinata.cloud/pinning/pinJSONToIPFS', {\n  method: \"POST\", \n  headers: {\n    'Autorization': `Bearer: ${keyInfo.message.token}`, \n    'Content-Type': 'application/json'\n  }, \n  body: JSON.stringify({\n    pinataOptions: {\n      cidVersion: 1, \n    }, \n    pinataMetadata: {\n      name: \"metadata.json\"\n    },\n    pinataContent: contractUriJSON\n  })\n})\n\nconst uriData = await jsonRes.json()\nconsole.log(uriData)\n```\nThat’s it. Similar to the ERC20 flow, we upload the JSON to IPFS and we now have a URI we can use in our token’s contract. \n## What’s next?\nIn a future tutorial, we’ll show you how to deploy an ERC20 token contract as well as a Solana SPL token. For now, though, you have everything you need to start building tools that will get your memecoin’s media hosted on IPFS to preserve the public nature of the coin. \nThis tutorial covered using Dynamic for wallet access, Next.js for server and client code, and Pinata for hosting images and JSON on IPFS. Now, you can create your own custom memecoins. When you are ready to display the memes associated with these coins, you simply need to fetch the image from IPFS using your dedicated gateway. If you remember, the image’s URI format uses the IPFS protocol URI like this: ipfs://CID. This creates maximum flexibility because you or anyone else can use any gateway they’d like to load the image. The dedicated IPFS gateway that comes with your Pinata account will be the fastest and most reliable way to load this content. It has a built in CDN and image optimization tools. \nYou’ll be well equipped for memeing to your heart’s content. Happy Pinning!\n",
    "Status": {
      "id": "%40%5ElI",
      "type": "status",
      "status": {
        "id": "bHQW",
        "name": "Ready for Webflow",
        "color": "purple"
      }
    },
    "Writer": {
      "id": "Fm%7CA",
      "type": "people",
      "people": [
        {
          "object": "user",
          "id": "c5fb87a6-8ac5-4696-b325-b3b6ca0be65e",
          "name": "Isabel Bruda",
          "avatar_url": "https://lh3.googleusercontent.com/a/ALm5wu04x7-NU6Q9clfYsa2s6Y44bzv7uT8eQt2wfEQ_=s100",
          "type": "person",
          "person": {
            "email": "isabel.bruda@pinata.cloud"
          }
        }
      ]
    },
    "Reviewers": {
      "id": "QlBG",
      "type": "people",
      "people": []
    },
    "Topic": {
      "id": "R%7DAw",
      "type": "select",
      "select": null
    },
    "Delivery Date": {
      "id": "Sj%5EU",
      "type": "date",
      "date": {
        "start": "2024-05-21",
        "end": null,
        "time_zone": null
      }
    },
    "Priority": {
      "id": "w%5B%7DO",
      "type": "select",
      "select": null
    },
    "Content-Type": {
      "id": "%7D%3C%3FG",
      "type": "select",
      "select": {
        "id": "EMXi",
        "name": "Blog",
        "color": "orange"
      }
    },
    "Name": {
      "id": "title",
      "type": "title",
      "title": [
        {
          "type": "text",
          "text": {
            "content": "[TEST] How To Notion2Webflow",
            "link": null
          },
          "annotations": {
            "bold": false,
            "italic": false,
            "strikethrough": false,
            "underline": false,
            "code": false,
            "color": "default"
          },
          "plain_text": "[TEST] How To Notion2Webflow",
          "href": null
        }
      ]
    }
  }
]